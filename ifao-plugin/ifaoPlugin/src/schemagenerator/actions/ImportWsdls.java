package schemagenerator.actions;


import ifaoplugin.*;

import java.io.*;
import java.text.*;
import java.util.*;

import net.ifao.xml.*;


/** 
 * class ImportWsdls 
 * 
 * <p> 
 * Copyright &copy; 2011, i:FAO 
 * 
 * @author brod 
 */
public class ImportWsdls
{
   private static final String REPLACEXMLTAG = "_replaceXmlTag";
   private DataWsdl _conn;

   /** 
    * Constructor ImportWsdls 
    * 
    * @param pConn DataWsdl connections
    * 
    * @author brod 
    */
   public ImportWsdls(DataWsdl pConn)
   {
      _conn = pConn;
   }

   /** 
    * Method saveJavaCommunication 
    * @param psUrl url string
    * @return 
    * 
    * @author Andreas Brod 
    */
   public String saveJavaCommunication(String psUrl)
   {
      StringBuffer sbResult = new StringBuffer();

      String sJavaCommunication = _conn.getJavaCommunication().replace('\\', '/');

      String sSource = loadTempWsdlFile(sJavaCommunication);

      String sWsdlSchema = loadFromURL(psUrl);

      // quickfix for BeNe; should be replaced by a more common version ;-)
      if (sWsdlSchema.indexOf("<wsdl:types/>") >= 0) {
         sWsdlSchema = Util.replaceString(sWsdlSchema, "<wsdl:types/>", "");
      }

      String sProvider;
      int iStartAgents = sJavaCommunication.indexOf("arctic/agents/");
      if (iStartAgents <= 0) {
         return "";
      }

      sProvider = sJavaCommunication.substring(iStartAgents + 14);

      sProvider = sProvider.substring(0, sProvider.indexOf("/"));

      // replace "/" or "\" with "_" (last character is "/" or "\" )

      sProvider = Util.camelCase(sProvider);

      XmlObject wsdlObject = new XmlObject(sWsdlSchema).getFirstObject();

      // import sub wsdls
      XmlObject[] wsdlImport = wsdlObject.getObjects("import");
      for (int i = 0; i < wsdlImport.length; i++) {
         XmlObject xmlImport =
            new XmlObject(loadFromURL(wsdlImport[i].getAttribute("location"))).getFirstObject();
         // add the types
         XmlObject[] types = xmlImport.getObjects("types");
         for (int j = 0; j < types.length; j++) {
            wsdlObject.addObject(types[j]);
         }
         // add the messages
         XmlObject[] messages = xmlImport.getObjects("message");
         for (int j = 0; j < messages.length; j++) {
            wsdlObject.addObject(messages[j]);
         }
         // add the portType
         XmlObject[] portTypes = xmlImport.getObjects("portType");
         for (int j = 0; j < portTypes.length; j++) {
            wsdlObject.addObject(portTypes[j]);
         }

      }

      // remove the imports
      XmlObject types = wsdlObject.getObject("types");
      if (types != null && psUrl != null && psUrl.length() > 0) {
         int iMax = Math.max(psUrl.lastIndexOf("/"), psUrl.lastIndexOf("\\")) + 1;
         if (iMax > 1) {
            XmlObject schema = types.getObject("schema");
            if (schema != null) {
               removeImports(schema, psUrl.substring(0, iMax), new HashSet<String>());
            }
         }
      }

      String sServiceName = wsdlObject.createObject("service").getAttribute("name");

      // main! method to create java files
      updateWsdlFiles(wsdlObject, sProvider, sServiceName);

      sProvider += "ProviderData";

      String sWsdlSource = loadTempWsdlFile(".java");

      if ((sSource.length() > 0) && (sWsdlSource.length() > 0) && (sWsdlSchema.length() > 0)) {

         String sLastSource = sSource;

         // get the package

         String sName = sServiceName;

         if (sName.length() > 0) {
            sName = "[" + sName + "]";
         }
         sWsdlSource = getWsdlSource(psUrl, sWsdlSource, sName);

         String sPackage = "";

         while (sWsdlSource.startsWith("import ")) {
            String sImport = sWsdlSource.substring(0, sWsdlSource.indexOf("\n"));

            sPackage =
               new String(sImport.substring(sImport.indexOf(" ") + 1, sImport.lastIndexOf(".*")));

            sWsdlSource = sWsdlSource.substring(sWsdlSource.indexOf("\n") + 1);

            if (sSource.indexOf(sImport) < 0) {
               sSource =
                  sSource.substring(0, sSource.indexOf("import")) + sImport + "\n"
                        + sSource.substring(sSource.indexOf("import"));
            }
         }

         sSource =
            Util.replaceString(sSource, "public Object sendReceive", "private Object sendReceive");

         sSource =
            Util.replaceString(sSource, "public String sendReceive", "private String sendReceive");

         sWsdlSource =
            Util.replaceString(sWsdlSource, "_GENERATOR_",
                  "generated by " + System.getProperty("user.name"));

         if (sServiceName.length() > 0) {
            // remove 'old' startEnd
            sSource = fillInSource(sSource, "", "");
         }
         sSource = fillInSource(sSource, sWsdlSource, sName);

         // add eventually main START/END Section with common methods
         if (sServiceName.length() > 0) {
            sSource = addStartEndSection(sSource, sServiceName);
         }

         if (!sLastSource.equals(sSource)) {
            writeToFile(sJavaCommunication, sSource);
            sbResult.append("* " + sJavaCommunication + "\n");
         }

         // write data.xsd / dataBinding.xml
         String xsdData = loadTempWsdlFile("/" + sServiceName + ".data.xsd");
         int iSrcStart = sJavaCommunication.indexOf("src/net/ifao");

         if ((xsdData.length() > 0) && (sPackage.length() > 0) && (iSrcStart > 0)) {
            String sPath = sPackage.replace('.', '/');
            String sLibDir =
               Util.getProviderDataRootDirectory(sJavaCommunication.substring(0, iSrcStart), sPath)
                     + "/";

            String sDataXsd = sLibDir + sPath + '/' + sServiceName + ".data.xsd";
            String sOld = loadTempWsdlFile(sDataXsd);

            if (sOld.equals(xsdData)) {
               sbResult.append("* " + sLibDir + sPath + "/data.xsd\n");
            } else {

               writeToFile(sDataXsd, xsdData);
               // createMainDataXsd(sLibDir + sPath);

               sbResult.append("* " + sLibDir + sPath + "/data.xsd\n");
               sbResult.append("* " + sLibDir + sPath + '/' + sServiceName + ".data.xsd\n");
               sbResult.append("* " + sLibDir + sPath + "/dataBinding.xml\n");

            }

         }

      }

      if (sbResult.length() > 0) {
         sbResult.append("\nwith * marked files have to be submitted (in CVS) !\n");
      }
      return sbResult.toString();
   }

   /** 
    * private method to remove the imports (and import the additional schemas directly) 
    * 
    * @param schema schema
    * @param psPath Path
    * @param hashSet hashSet (to avoid duplicate imports)
    * 
    * @author brod 
    */
   private void removeImports(XmlObject schema, String psPath, HashSet<String> hashSet)
   {
      XmlObject[] imports = schema.deleteObjects("import");
      int iObjectCount = schema.getObjects("").length;
      for (int i = 0; i < imports.length; i++) {
         String sSchemaLocation = imports[i].getAttribute("schemaLocation");
         if (sSchemaLocation.length() > 0 && hashSet.add(sSchemaLocation)) {
            String sUrl =
               !sSchemaLocation.contains("/") ? psPath + sSchemaLocation : sSchemaLocation;
            XmlObject schemaNew = new XmlObject(loadFromURL(sUrl)).getFirstObject();
            String sNewNamespace = imports[i].getAttribute("namespace");
            if (schemaNew.getAttribute("targetNamespace").equals(sNewNamespace)) {
               removeImports(schemaNew, psPath, hashSet);
               XmlObject[] objects = schemaNew.getObjects("");
               for (int j = 0; j < objects.length; j++) {
                  schema.addObject(objects[j]);
               }
               if (iObjectCount == 0 || schema.getAttribute("targetNamespace").length() == 0) {
                  schema.setAttribute("targetNamespace", sNewNamespace);
               }
            }
         }
      }
   }


   /** 
    * private method addStartEndSection 
    * 
    * @param psSource source
    * @param psName Name
    * @return modified string
    * 
    * @author brod 
    */
   private String addStartEndSection(String psSource, String psName)
   {
      try {

         int iStart = psSource.indexOf("// ---- START");
         int iEnd = psSource.lastIndexOf("// ---- END");
         String sGlobalMethods = "";
         if (iStart > 0 && iEnd > iStart) {
            // extract section
            String sSection = psSource.substring(iStart + 13, iEnd);
            // section may not contain a startEnd
            if (sSection.indexOf("// ---- START") < 0) {
               int iPublic = 0;
               while ((iPublic = sSection.indexOf(" public ", iPublic + 1)) > 0) {
                  iStart = sSection.lastIndexOf("/**", iPublic);
                  iEnd = sSection.indexOf("{", iPublic) + 1;
                  if (iStart > 0 && iEnd > iStart) {
                     String sMethod = sSection.substring(iStart, iEnd);
                     iStart = sMethod.lastIndexOf("(");
                     iEnd = sMethod.lastIndexOf(")");
                     if (iStart > 0 && iEnd >= iStart) {
                        String params = sMethod.substring(iStart + 1, iEnd);
                        StringTokenizer st = new StringTokenizer(params, ",");
                        String sMethodName =
                           sMethod.substring(sMethod.lastIndexOf(" ", iStart) + 1, iStart);
                        sGlobalMethods += "   " + sMethod.replaceAll("\\n    ", "\n") + "\n";

                        if (sMethod.indexOf(" void ") < 0)
                           sGlobalMethods += "     return ";
                        sGlobalMethods +=
                           psName.charAt(0) + Util.camelCase(psName).substring(1) + "."
                                 + sMethodName + "(";
                        while (st.hasMoreTokens()) {
                           String nextToken = st.nextToken().replaceAll("\\n", "").trim();
                           sGlobalMethods += nextToken.substring(nextToken.lastIndexOf(" ") + 1);
                           if (st.hasMoreTokens()) {
                              sGlobalMethods += ",";
                           }
                        }
                        sGlobalMethods += ");\n";

                        sGlobalMethods += "   }\n\n";
                     }
                  }
               }
            }

         }
         if (sGlobalMethods.length() > 0) {
            // deactivate setActualCommunication in case of one wsdl
            psSource =
               psSource.replaceAll("   setActualCommunication\\(", "   // setActualCommunication(");

            sGlobalMethods =
               "   // ---- START ------------------------------\n" + sGlobalMethods
                     + "   // ---- END --------------------------------\n";
            psSource = fillInSource(psSource, sGlobalMethods, "");
         } else {
            // ensure, that setActualCommunication is available
            if (psSource.indexOf(" void setActualCommunication(") < 0) {
               iStart = psSource.indexOf("// ---- START");
               if (iStart < 0)
                  iStart = psSource.lastIndexOf("}");
               iStart = psSource.lastIndexOf("\n", iStart) + 1;
               psSource =
                  psSource.substring(0, iStart)
                        + "   private void setActualCommunication(String psCommunicationName)\n"
                        + "   {\n" + "      // TODO Auto-generated method stub\n" + "   }\n\n"
                        + psSource.substring(iStart);
            }
         }
      }
      catch (Exception ex) {}
      return psSource;
   }

   /** 
    * private method fillInSource 
    * 
    * @param psSource Source
    * @param psWsdlSource WsdlSource
    * @param psName Name
    * @return modified string
    * 
    * @author brod 
    */
   private String fillInSource(String psSource, String psWsdlSource, String psName)
   {
      int iStart = psSource.lastIndexOf("// ---- START" + psName + " -");

      int iEnd;
      if (iStart < 0) {
         iStart = psSource.lastIndexOf("}");
         iEnd = iStart;
      } else {
         iStart = psSource.lastIndexOf("\n", iStart) + 1;
         iEnd = psSource.lastIndexOf("// ---- END" + psName + " -", iStart);
         if (iEnd < 0) {
            iEnd = psSource.lastIndexOf("}");
         } else {
            iEnd = psSource.indexOf("\n", iEnd) + 1;
         }
      }

      return psSource.substring(0, iStart) + psWsdlSource + psSource.substring(iEnd);
   }

   /** 
    * private method loadFromURL 
    * 
    * @param psUrl Url string
    * @return loaded content (from url)
    * 
    * @author brod 
    */
   private String loadFromURL(String psUrl)
   {
      String sLoadURL = Data.loadURL(psUrl);
      // try to unformat UTF-8
      try {
         String sUtf8String = new String(sLoadURL.getBytes(), "UTF-8");
         while (sUtf8String.length() < sLoadURL.length()) {
            sLoadURL = sUtf8String;
            sUtf8String = new String(sLoadURL.getBytes(), "UTF-8");
         }
      }
      catch (UnsupportedEncodingException e) {
         // should never happen on UTF-8
      }
      return sLoadURL;
   }

   /** 
    * private method writeToFile 
    * 
    * @param psFileName filename
    * @param psText text to write
    * 
    * @author brod 
    */
   private void writeToFile(String psFileName, String psText)
   {
      Data.writeFile(psFileName, psText);
   }

   /** 
    * private method writeToConn 
    * 
    * @param psFileName filename
    * @param psText text to write
    * 
    * @author brod 
    */
   private void writeToConn(String psFileName, String psText)
   {
      Data.writeFile("Temp/Wsdl" + psFileName, psText);
   }

   /** 
    * private method loadFromFile 
    * 
    * @param psFilename Filename
    * @return text (form the file)
    * 
    * @author brod 
    */
   private String loadTempWsdlFile(String psFilename)
   {
      if (psFilename.startsWith(".") || psFilename.startsWith("/"))
         psFilename = "Temp/Wsdl" + psFilename;
      return Data.loadFile(new File(psFilename));
   }

   /** 
    * private method getWsdlSource
    *  
    * @param psUrl Url
    * @param psWsdlSource  WsdlSource
    * @param psName Name
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String getWsdlSource(String psUrl, String psWsdlSource, String psName)
   {

      // get the imports
      String sImport = "";

      while (psWsdlSource.startsWith("import ")) {
         sImport += psWsdlSource.substring(0, psWsdlSource.indexOf("\n") + 1);

         psWsdlSource = psWsdlSource.substring(psWsdlSource.indexOf("\n") + 1);
      }

      String sHeader =
         "   // The following lines are automatically generated with the\n"
               + "   // ArcticRequester generation menu. Please do not edit any\n"
               + "   // lines below, because these are deleted. If you want to add\n"
               + "   // some code, please use the lines above.\n"
               + "   // -----------------------------------------------------------\n"
               + "   // URL: " + psUrl.replaceAll("\\\\", "/") + "\n   // DATE: "
               + (new SimpleDateFormat("yyyy-MM-dd HH:mm").format(new Date())) + "\n";

      psName += " -";
      while (psName.length() < 49)
         psName += "-";
      psWsdlSource = "   // ---- START" + psName + "\n" + sHeader + psWsdlSource;
      psWsdlSource += "   // ---- END" + psName + "--\n";
      // sWsdlSource += "\n}\n";

      return sImport + psWsdlSource;
   }

   /** 
    * private method updateWsdlFiles 
    * 
    * @param pXmlWdl xml object
    * @param psProvider Provider 
    * @param psName Name
    * 
    * @author Andreas Brod 
    */
   private void updateWsdlFiles(XmlObject pXmlWdl, String psProvider, String psName)
   {
      pXmlWdl.createObject("service");
      XmlObject binding = pXmlWdl.createObject("binding");
      XmlObject[] operation = binding.getObjects("operation");

      String sImport = url2ImportPath(pXmlWdl.getAttribute("targetNamespace"));

      XmlObject schema = pXmlWdl.createObject("types").createObject("schema");

      if (sImport.length() == 0) {
         String nameSpace = schema.getNameSpace();

         sImport = url2ImportPath(schema.getAttribute(nameSpace));
      }

      if (schema.getObjects("").length == 0) {
         sImport = "";
      }

      if (sImport.length() > 0) {
         sImport = "import " + sImport + ".*;\n";
      }

      StringBuffer sbJava = new StringBuffer();
      HashSet<String> hsExceptions = new HashSet<String>();

      createDataBindingFiles(pXmlWdl, psName);

      for (int i = 0; i < operation.length; i++) {
         String sOperation = operation[i].getAttribute("name");
         boolean bLiteal =
            operation[i].createObject("input").createObject("body").getAttribute("use")
                  .equalsIgnoreCase("literal");

         String sJavaOperation = loadWSDLObject(pXmlWdl, sOperation, hsExceptions, psName, bLiteal);

         while (sJavaOperation.startsWith("import ")) {

            // validate import
            if (sImport.length() == 0) {
               sImport = sJavaOperation.substring(0, sJavaOperation.indexOf("\n") + 1);
            }

            // trunc Import from response
            sJavaOperation = sJavaOperation.substring(sJavaOperation.indexOf("\n") + 1);
         }

         // add Java operation
         sbJava.append(sJavaOperation + "\n");
      }

      if ((sImport.length() > 0) && (sbJava.indexOf(sImport) < 0)) {
         sbJava.insert(0, sImport);
      }

      if (sbJava.indexOf(" _getParamType(") > 0) {
         sbJava.append(getParamTypeMethod());
      }

      if (psProvider.length() > 0) {
         String sHeader = "";
         sbJava.append(getInnerMethod(hsExceptions, psProvider));
         if (psName.length() > 0) {
            StringTokenizer st = new StringTokenizer(sbJava.toString(), "\n\r");
            sbJava = new StringBuffer();
            sbJava.append("   public " + Util.camelCase(psName) + "Class " + psName.charAt(0)
                  + Util.camelCase(psName).substring(1) + " = new " + Util.camelCase(psName)
                  + "Class();\n\n");
            sbJava.append("   public class " + Util.camelCase(psName) + "Class {\n");
            while (st.hasMoreTokens()) {
               String sLine = st.nextToken() + "\n";
               if (sLine.startsWith("import") || sLine.trim().startsWith("private static Object _")) {
                  sHeader += sLine;
               } else {
                  sbJava.append("   " + sLine);
               }
            }
            sbJava.append("   }\n");
         }
         writeToConn(".java", sHeader + sbJava.toString());
      }
   }

   /** 
    * private for method to create DataBindingFiles 
    * 
    * @param pXmlWsdlObject wsdl object
    * @param psServiceName ServiceName
    * 
    * @author brod 
    */
   private void createDataBindingFiles(XmlObject pXmlWsdlObject, String psServiceName)
   {
      // get the schema(s)
      XmlObject schema = WsdlObject.getSchema(pXmlWsdlObject.toString());

      // create the dataBindings
      writeToConn("/" + psServiceName + ".data.xsd", schema.toString());
   }

   /** 
    * Method getInnerMethod 
    * 
    * 
    * @param phsExceptions 
    * @param psProvider 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String getInnerMethod(HashSet<String> phsExceptions, String psProvider)
   {
      StringBuffer sb = new StringBuffer();

      sb.append("    /**\n");
      sb.append("     * The method " + REPLACEXMLTAG + " extracts the 'inner' area\n");
      sb.append("     * from <code>psText</code> and surrounds it with\n");
      sb.append("     * a <code>psToTag</code> tag.\n");
      sb.append("     *\n");
      sb.append("     * @param psFromTag This element has to be extracted\n");
      sb.append("     * @param psToTag The element has to 'frame' the\n");
      sb.append("     * result\n");
      sb.append("     * @param psText The response object which has\n");
      sb.append("     * to be analysed\n");
      sb.append("     * @return The modified result.\n");
      sb.append("     * @author _GENERATOR_\n");
      sb.append("     * @throws AgentException\n");
      sb.append("     */\n");
      sb.append("    private String " + REPLACEXMLTAG
            + "(String psFromTag, String psToTag, String psText)\n");
      sb.append("        throws AgentException\n");
      sb.append("    {\n");
      sb.append("        return " + REPLACEXMLTAG + "(psFromTag, psToTag, psText, true);\n");
      sb.append("    }\n");
      sb.append("\n");
      sb.append("    /**\n");
      sb.append("     * The private Method getStartTag gets the location of a Tag \n");
      sb.append("     * named in psType, which is within the response (psResponse)\n");
      sb.append("     *\n");
      sb.append("     * @param psResponse The responseString with the Elements\n");
      sb.append("     * @param psType The searchText of the tag\n");
      sb.append("     *\n");
      sb.append("     * @return\n");
      sb.append("     * @author _GENERATOR_\n");
      sb.append("     */\n");
      sb.append("    private int getStartTag(String psResponse, String psType)\n");
      sb.append("    {\n");
      sb.append("\n");
      sb.append("        // get the StartTag\n");
      sb.append("        int iStart = -1;\n");
      sb.append("\n");
      sb.append("        char[] cEndItems = \" />\".toCharArray();\n");
      sb.append("\n");
      sb.append("        for (int i = 0; (iStart < 0) && (i < cEndItems.length); i++) {\n");
      sb.append("            iStart = psResponse.indexOf(\"<\" + psType + cEndItems[i]);\n");
      sb.append("\n");
      sb.append("            if (iStart < 0) {\n");
      sb.append("                iStart = psResponse.indexOf(\":\" + psType + cEndItems[i]);\n");
      sb.append("            }\n");
      sb.append("        }\n");
      sb.append("\n");
      sb.append("        if (iStart >= 0) {\n");
      sb.append("            return psResponse.indexOf(\">\", iStart) + 1;\n");
      sb.append("        }\n");
      sb.append("\n");
      sb.append("        return iStart;\n");
      sb.append("    }\n");
      sb.append("\n");
      sb.append("    /**\n");
      sb.append("     * Method " + REPLACEXMLTAG + "\n");
      sb.append("     * @param psType\n");
      sb.append("     * @param psFrame\n");
      sb.append("     * @param psResponse\n");
      sb.append("     * @param pbRecurse\n");
      sb.append("     * @return\n");
      sb.append("     * @throws AgentException\n");
      sb.append("     * @author _GENERATOR_\n");
      sb.append("     */\n");
      sb.append("    private String " + REPLACEXMLTAG
            + "(String psType, String psFrame, String psResponse,\n");
      sb.append("                             boolean pbRecurse)\n");
      sb.append("        throws AgentException\n");
      sb.append("    {\n");
      sb.append("\n");
      sb.append("        // get the StartTag\n");
      sb.append("        int iStart = getStartTag(psResponse, psType);\n");
      sb.append("\n");
      sb.append("        if (iStart < 0 && !Common.empty(psFrame)) {\n");
      sb.append("            // search if there is the Frame available, because this might also\n");
      sb.append("            // be returned.\n");
      sb.append("            psType = psFrame;\n");
      sb.append("            iStart = getStartTag(psResponse, psType);\n");
      sb.append("        }\n");
      sb.append("\n");
      sb.append("        // if the StartTag is found\n");
      sb.append("        if (iStart >= 0) {\n");
      sb.append("\n");
      sb.append("            // get the EndTag\n");
      sb.append("            int iEnd = psResponse.lastIndexOf(\"/\" + psType + \">\");\n");
      sb.append("\n");
      sb.append("            if (iEnd < 0) {\n");
      sb.append("                iEnd = psResponse.lastIndexOf(\":\" + psType + \">\");\n");
      sb.append("            }\n");
      sb.append("\n");
      sb.append("            if (iEnd > 0) {\n");
      sb.append("                iEnd = psResponse.lastIndexOf(\"<\", iEnd);\n");
      sb.append("            }\n");
      sb.append("\n");
      sb.append("            // ... there is a valid response\n");
      sb.append("            if (iEnd > iStart) {\n");
      sb.append("                psResponse = psResponse.substring(iStart, iEnd);\n");
      sb.append("            } else {\n");
      sb.append("                psResponse = \"\";\n");
      sb.append("            }\n");
      sb.append("\n");
      sb.append("            // \"frame\" the response\n");
      sb.append("            if (psFrame.length() > 0) {\n");
      sb.append("                return \"<\" + psFrame + \">\" + psResponse + \"</\" + psFrame + \">\";\n");
      sb.append("            }\n");
      sb.append("\n");
      sb.append("            return psResponse;\n");
      sb.append("        }\n");
      sb.append("\n");

      sb.append("        if (pbRecurse) {\n");
      sb.append("\n");

      for (Iterator<String> i = phsExceptions.iterator(); i.hasNext();) {
         String sNext = i.next();

         sb.append("            if (getStartTag(psResponse, \"" + sNext + "\") > 0) {\n");
         sb.append("                Object exceptionObject = CastorSerializer.unmarshalProviderResponse(\n");
         sb.append("                    " + REPLACEXMLTAG + "(\n");
         sb.append("                    \"" + sNext + "\", \"" + sNext
               + "\", psResponse, false),\n");
         sb.append("                    " + sNext + ".class, log, false);\n");
         sb.append("\n");
         sb.append("                throw new " + psProvider
               + "Exception(exceptionObject, log, false);\n");
         sb.append("\n");
         sb.append("            }\n");
      }

      sb.append("            if (getStartTag(psResponse, \"Fault\") > 0) {\n");
      sb.append("                String exceptionObject = " + REPLACEXMLTAG
            + "(\"Fault\", \"\", psResponse,\n");
      sb.append("                                                   false);\n");
      sb.append("\n");
      sb.append("                throw new " + psProvider
            + "Exception(exceptionObject, log, true);\n");
      sb.append("            }\n");
      sb.append("            throw new " + psProvider + "Exception(psResponse, log, true);\n");

      sb.append("        }\n");
      sb.append("\n");
      sb.append("        throw new AgentException(AgentErrors.INVALID_RESPONSE,\n");
      sb.append("                                 ResEnumErrorCategory.AGENT,\n");
      sb.append("                                 ResEnumErrorComponent.ARCTIC_HTTP_SOAP, \"\",\n");
      sb.append("                                 new Exception(\"Invalid Provider Response\"),\n");
      sb.append("                                 log);\n");
      sb.append("\n");
      sb.append("\n");
      sb.append("    }\n");
      sb.append("\n");

      return sb.toString();
   }

   /** 
    * The method getParamTypeMethod returns the complete sourcecode for 
    * the method _getParamType 
    * 
    * @return The SourceCode for the  ParamTypeMethod 
    * 
    * @author brod 
    */
   private String getParamTypeMethod()
   {
      StringBuffer sb = new StringBuffer();
      sb.append("  /**\n");
      sb.append("    * The method _getParamType returns the 'correct' type according\n");
      sb.append("    * to the defined namespaces.\n");
      sb.append("    *\n");
      sb.append("    * @param psType The 'raw' type\n");
      sb.append("    * @return The formated type e.g. xsi:type='xsd:string'\n");
      sb.append("    *\n");
      sb.append("    * @author _GENERATOR_\n");
      sb.append("    */\n");
      sb.append("   private String _getParamType(String psType)\n");
      sb.append("    {\n");
      sb.append("       InitHttpSoapCommunication initCommunication = (InitHttpSoapCommunication) _httpCommunication\n");
      sb.append("             .getInitCommunication();\n");
      sb.append("\n");
      sb.append("       String schemaInstanceNamespace = initCommunication.getSchemaInstanceNamespace();\n");
      sb.append("       String schemaNamespace = initCommunication.getSchemaNamespace();\n");
      sb.append("       if (schemaInstanceNamespace.length() == 0 || schemaNamespace.length() == 0) {\n");
      sb.append("          return \"\";\n");
      sb.append("       }\n");
      sb.append("       return \" \" + schemaInstanceNamespace + \":type=\\\"\" + \"\" + schemaNamespace + \":\" + psType\n");
      sb.append("             + \"\\\"\";\n");
      sb.append("    }\n");

      return sb.toString();
   }

   /** 
    * Method getInputWSDLObject 
    * 
    * @param pXmlWsdlObject wsdl object
    * @param psMethod 
    * @param phsExceptions 
    * @param psName 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String loadWSDLObject(XmlObject pXmlWsdlObject, String psMethod,
                                 HashSet<String> phsExceptions, String psName, boolean pbLiteral)
   {
      String sRet = "";
      String sParams = "";

      // load the wsdlObject
      WsdlObject wsdlObject = new WsdlObject(new File(pXmlWsdlObject.getAttribute("fileName")));

      // get portType and additional types (with schema)
      XmlObject[] portType = pXmlWsdlObject.getObjects("portType");
      XmlObject types = pXmlWsdlObject.createObject("types");

      // search through the protTypes
      for (int i = 0; i < portType.length; i++) {
         XmlObject operation = portType[i].findSubObject("operation", "name", psMethod);

         // if an operation is found ...
         if (operation != null) {

            String sMessageTns = operation.createObject("input").getAttribute("message");
            if (sMessageTns.indexOf(":") > 0) {
               sMessageTns = sMessageTns.substring(0, sMessageTns.indexOf(":") + 1);
            } else {
               sMessageTns = "";
            }

            // get the message for this operation
            String sMessageInput = ":" + operation.createObject("input").getAttribute("message");

            String sMessageOutput = ":" + operation.createObject("output").getAttribute("message");

            String sMessageFault = ":" + operation.createObject("fault").getAttribute("message");

            // get the soapAction (if neccessary)
            String soapAction =
               getSoapAction(pXmlWsdlObject, portType[i].getAttribute("name"), psMethod);

            // get the inputNameSpace
            String inputNameSpace =
               getInputNamespace(pXmlWsdlObject, portType[i].getAttribute("name"), psMethod);

            String inputPackage =
               getInputPackage(pXmlWsdlObject, portType[i].getAttribute("name"), psMethod);
            if (inputPackage.length() > 0)
               inputPackage += ".";
            boolean bAddImport = false;

            String sOutputType = "";

            // if the is a message

            if (sMessageOutput.length() > 1) {

               // search a the related message-object
               XmlObject messageOutput =
                  pXmlWsdlObject.findSubObject("message", "name",
                        sMessageOutput.substring(sMessageOutput.lastIndexOf(":") + 1));

               String sOutputTypeOrg = sOutputType;

               if (messageOutput != null) {

                  // get the first response
                  XmlObject part = messageOutput.getObject("part");

                  if (part != null) {
                     sOutputType = part.getAttribute("type");

                     if (sOutputType.length() == 0) {
                        sOutputType = part.getAttribute("element");
                     }

                     if (sOutputType.indexOf(":") > 0) {
                        sOutputTypeOrg = sOutputType.substring(sOutputType.lastIndexOf(":") + 1);
                        sOutputType = Util.camelCase(sOutputTypeOrg);

                     } else {
                        sOutputType = Util.camelCase(sOutputType);
                     }

                     sOutputType = sOutputType + " " + part.getAttribute("name");
                  }
               }

               // search a the related message-object
               XmlObject messageInput =
                  pXmlWsdlObject.findSubObject("message", "name",
                        sMessageInput.substring(sMessageInput.lastIndexOf(":") + 1));

               // get the faultException
               XmlObject messageFault =
                  pXmlWsdlObject.findSubObject("message", "name",
                        sMessageFault.substring(sMessageFault.lastIndexOf(":") + 1));

               XmlObject binding =
                  pXmlWsdlObject.createObject("binding", "type",
                        sMessageTns + portType[i].getAttribute("name"), true);

               String sException = "";

               if (messageFault != null) {
                  XmlObject partFault = messageFault.getObject("part");

                  if (partFault.getAttribute("element").length() > 0) {
                     sException = partFault.getAttribute("element");
                  } else if (partFault.getAttribute("type").length() > 0) {
                     sException = partFault.getAttribute("type");
                  }

                  if (sException.indexOf(":") > 0) {
                     sException = sException.substring(sException.indexOf(":") + 1);
                  }

                  if (sException.length() > 0) {
                     phsExceptions.add(sException);
                  }
               }

               if (messageInput != null) {

                  // ... now we have a message object with input/output
                  XmlObject[] partInput = messageInput.getObjects("part");

                  sRet = "";

                  sParams = "";

                  boolean bIsSoapAction =
                     soapAction.length() > 0
                           && !binding.createObject("binding").getAttribute("style")
                                 .equalsIgnoreCase("rpc");

                  if (bIsSoapAction) {
                     sRet += "<!-- SOAPAction: " + soapAction + " -->";
                  }

                  // if there are no parts, there is a void method
                  if (partInput.length == 0) {

                     if (inputNameSpace.length() > 0) {
                        sRet += "<m:" + psMethod + " xmlns:m=\"" + inputNameSpace + "\"" + " />";
                     } else {
                        sRet += "<" + psMethod + " />";
                     }
                  }

                  List<String> listNames = new Vector<String>();
                  List<String> listTypes = new Vector<String>();
                  List<String> listClasses = new Vector<String>();

                  for (int j = 0; j < partInput.length; j++) {
                     String sName = partInput[j].getAttribute("name");
                     String sType = partInput[j].getAttribute("type");
                     String sElement = partInput[j].getAttribute("element");

                     if (sParams.length() > 0) {
                        sParams += ", ";
                     }

                     if (sType.length() == 0) {
                        sType = sElement;
                     }

                     if (sType.trim().length() > 0) {

                        // add the type to the java Source
                        if (sType.indexOf(":") > 0) {
                           sType = sType.substring(sType.lastIndexOf(":") + 1);
                        }

                        listTypes.add(sType);

                        sType = Util.camelCase(sType);

                        // correct types
                        if (sType.equalsIgnoreCase("int") || sType.equalsIgnoreCase("long")
                              || sType.equalsIgnoreCase("float")
                              || sType.equalsIgnoreCase("boolean")) {
                           sType = sType.toLowerCase();
                        }

                        // for standard Java types, ignore the input package
                        if (sType.equalsIgnoreCase("int") || sType.equalsIgnoreCase("long")
                              || sType.equalsIgnoreCase("float")
                              || sType.equalsIgnoreCase("boolean")
                              || sType.equalsIgnoreCase("integer")
                              || sType.equalsIgnoreCase("string")) {
                           sParams += sType + " ";
                        } else {
                           sParams += inputPackage + sType + " ";
                        }

                        listClasses.add(sType);

                        // add the Name to the java Source
                        if (sName.indexOf(":") > 0) {
                           listNames.add(sName.substring(sName.lastIndexOf(":") + 1));
                        } else {
                           listNames.add(sName);
                        }

                        sParams += listNames.get(listNames.size() - 1);

                        if (sElement.length() > 0) {
                           sRet += wsdlObject.getWsdlElement(sElement, types, false);
                        } else {
                           if (j == 0) {
                              sRet += "<m:" + psMethod;

                              if (inputNameSpace.length() > 0) {
                                 sRet += " xmlns:m=\"" + inputNameSpace + "\"";
                              }

                              sRet += ">";
                           }

                           wsdlObject.searchTypes(partInput[j], null, types, "");

                           // sRet += part[j];
                           sRet += wsdlObject.getElement(partInput[j], "", "");

                           if (j + 1 == partInput.length) {
                              sRet += "</m:" + psMethod + ">";
                           }
                        }
                     }
                  }

                  String sHeader = "    /**\n";

                  sHeader += "    * The method " + psMethod + " is automatically generated\n";
                  sHeader += "    * \n";

                  String psMethodJava = Util.camelCase(psMethod);
                  // don't replace first char
                  psMethodJava = psMethod.substring(0, 1) + psMethodJava.substring(1);

                  String sJava = "";

                  // create the JavaSourceCode
                  if (sOutputType.length() > 0) {
                     String sOutType = sOutputType.substring(0, sOutputType.indexOf(" "));
                     // for standard Java types, ignore the input package
                     if (sOutType.equalsIgnoreCase("int") || sOutType.equalsIgnoreCase("long")
                           || sOutType.equalsIgnoreCase("float")
                           || sOutType.equalsIgnoreCase("boolean")
                           || sOutType.equalsIgnoreCase("integer")
                           || sOutType.equalsIgnoreCase("string")) {
                        sJava =
                           "    public " + sOutType + " " + psMethodJava + "(" + sParams
                                 + ")\n        throws AgentException {\n";
                     } else {
                        sJava =
                           "    public " + inputPackage + sOutType + " " + psMethodJava + "("
                                 + sParams + ")\n        throws AgentException {\n";
                     }

                  } else {
                     sJava =
                        "    public void " + psMethodJava + "(" + sParams
                              + ")\n        throws AgentException {\n";
                  }

                  sJava += "        StringBuffer sbRequest = new StringBuffer();\n\n";

                  sJava += "        setActualCommunication(\"" + psName + "\");\n";

                  if (bIsSoapAction) {
                     sJava += "        setSOAPAction(\"" + soapAction + "\");\n\n";
                  } else if (!pbLiteral) {

                     // if there is no soapAction ... add the method
                     if (inputNameSpace.length() > 0) {
                        sJava +=
                           "        sbRequest.append(\"<m:" + psMethod + " xmlns:m=\\\""
                                 + inputNameSpace + "\\\">\");\n";
                     } else {
                        sJava += "        sbRequest.append(\"<m:" + psMethod + ">\");\n";
                     }
                  }

                  // add parameters
                  if (listNames.size() > 0) {
                     sJava += "\n        // add parameters\n\n";
                  } else {
                     sJava += "\n        // no parameters defined\n\n";
                  }

                  for (int iLst = 0; iLst < listNames.size(); iLst++) {
                     sHeader +=
                        "    * @param " + listNames.get(iLst) + " parameter " + (iLst + 1) + "\n";

                     String sClass = listClasses.get(iLst);
                     String sElement = listNames.get(iLst);

                     if (sClass.equalsIgnoreCase("String") || sClass.equalsIgnoreCase("int")
                           || sClass.equalsIgnoreCase("long") || sClass.equalsIgnoreCase("float")
                           || sClass.equalsIgnoreCase("boolean")) {
                        sJava +=
                           "        sbRequest.append(\"<" + sElement + "\" + _getParamType(\""
                                 + sClass.toLowerCase() + "\")+ \">\"+" + sElement + "+\"</"
                                 + sElement + ">\");\n";
                     } else {
                        bAddImport = true;
                        sHeader =
                           "    private static Object _" + psMethodJava + Util.camelCase(psName)
                                 + "Monitor = new Object();\n" + sHeader;
                        sJava +=
                           "        synchronized(_" + psMethodJava + Util.camelCase(psName)
                                 + "Monitor) {\n";

                        String sObj = "s" + Util.camelCase(listTypes.get(iLst));

                        sJava += "            // Convert Castor Object to String\n";
                        sJava +=
                           "            String " + sObj + " = CastorSerializer.marshalProviderRequest("
                                 + listNames.get(iLst) + ", false,\n";
                        sJava +=
                           "                                               "
                                 + "null, null, _bValidateRequest, log);\n";

                        if (!bIsSoapAction && !pbLiteral
                              && !listTypes.get(iLst).equals(listNames.get(iLst))) {
                           sJava +=
                              "            // " + listTypes.get(iLst) + " has to be "
                                    + listNames.get(iLst) + " for the request\n";
                           sJava +=
                              "            " + sObj + " = " + REPLACEXMLTAG + "(\""
                                    + listTypes.get(iLst) + "\", \"" + listNames.get(iLst) + "\", "
                                    + sObj + ");\n";
                        }

                        sJava += "            sbRequest.append(" + sObj + ");\n";

                        sJava += "        }\n";
                     }
                  }

                  // if there is no soapAction ... add the method
                  if (!bIsSoapAction && !pbLiteral) {

                     sJava += "\n        // close the method\n";
                     sJava += "        sbRequest.append(\"</m:" + psMethod + ">\");\n\n";
                  }

                  sJava += "\n        // get the Provider Response\n";

                  sJava += "        String sResponse = sendReceive(sbRequest.toString());\n\n";

                  if (sOutputType.length() > 0) {
                     sHeader += "    * @return response object\n";

                     // get the return value

                     String sClass = sOutputType.substring(0, sOutputType.indexOf(" "));

                     String sInner =
                        "" + REPLACEXMLTAG + "(\""
                              + sOutputType.substring(sOutputType.indexOf(" ") + 1)
                              + "\", \"\", sResponse)";

                     if (sClass.equalsIgnoreCase("String") || sClass.equals("string")) {
                        sJava += "        return " + sInner + ";\n";
                     } else if (sClass.equalsIgnoreCase("int")) {
                        sJava += "        return Integer.parseInt(" + sInner + ");\n";
                     } else if (sClass.equalsIgnoreCase("long")) {
                        sJava += "        return Long.parseLong(" + sInner + ");\n";
                     } else if (sClass.equalsIgnoreCase("float")) {
                        sJava += "        return Float.parseFloat(" + sInner + ");\n";
                     } else if (sClass.equalsIgnoreCase("boolean")) {
                        sJava += "        return Boolean.parseBoolean(" + sInner + ");\n";
                     } else {
                        sClass = inputPackage + sClass;
                        sInner =
                           "" + REPLACEXMLTAG + "(\""
                                 + sOutputType.substring(sOutputType.indexOf(" ") + 1) + "\", \""
                                 + sOutputTypeOrg + "\", sResponse)";

                        sJava +=
                           "        return (" + sClass
                                 + ") CastorSerializer.unmarshalProviderResponse(\n               " + sInner
                                 + ",\n               " + sClass
                                 + ".class, log, _bValidateResponse);\n";
                     }

                  }
                  sHeader += "    * @throws AgentException\n";
                  sHeader += "    * @author _GENERATOR_\n";

                  sHeader += "    */\n";

                  sJava = sHeader + sJava + "    }\n";

                  if ((inputPackage.length() > 0) && (sJava.indexOf("import " + inputPackage) < 0)
                        && bAddImport) {
                     sJava = "import " + inputPackage + "*;\n" + sJava + "";
                  }

                  return sJava;

               }
            }
         } // endif for this method
      }

      return sParams;

   }

   /** 
    * Method getInputPackage 
    * 
    * @param pXmlWsdl 
    * @param psBindingName 
    * @param psOperationName 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String getInputPackage(XmlObject pXmlWsdl, String psBindingName, String psOperationName)
   {
      String sNew = getInputNamespace(pXmlWsdl, psBindingName, psOperationName);

      if (sNew.length() == 0) {
         sNew = getSoapAction(pXmlWsdl, psBindingName, psOperationName);
      }

      return url2ImportPath(sNew);
   }

   /** 
    * Method getInputNamespace 
    * 
    * @param pXmlWsdl 
    * @param psBindingName 
    * @param psOprationName 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String getInputNamespace(XmlObject pXmlWsdl, String psBindingName, String psOprationName)
   {
      XmlObject operation = getOperation(pXmlWsdl, psBindingName, psOprationName);

      if (operation != null) {
         String s = "";

         // try to get the NameSpace from the message
         XmlObject[] message = pXmlWsdl.getObjects("message");

         for (int i = 0; i < message.length; i++) {
            if (((s.length() == 0) && message[i].getAttribute("name").equals(psOprationName))
                  || message[i].getAttribute("name").equals(":" + psOprationName)) {
               s = message[i].createObject("part").getAttribute("partns");
            }
         }

         if (s.length() == 0) {

            // get nameSpace from Body
            s = operation.createObject("input").createObject("body").getAttribute("namespace");

            // if stiil empty get the default
            if (s.length() == 0) {
               s = pXmlWsdl.getAttribute("targetNamespace");
            }
         }

         if (s.endsWith("/") || s.endsWith("\\")) {
            s = s.substring(0, s.length() - 1);
         }

         return s;
      }

      return "";
   }

   /** 
    * Method getSoapAction 
    * 
    * @param pXmlWsdl 
    * @param psBindingName 
    * @param psOperationName 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String getSoapAction(XmlObject pXmlWsdl, String psBindingName, String psOperationName)
   {
      XmlObject operation = getOperation(pXmlWsdl, psBindingName, psOperationName);

      if (operation != null) {
         String s = operation.createObject("operation").getAttribute("soapAction");

         if (s.endsWith("/") || s.endsWith("\\")) {
            s = s.substring(0, s.length() - 1);
         }

         return s;
      }

      return "";
   }

   /** 
    * Method getOperation 
    * 
    * @param pXmlWsdl 
    * @param psBindingName 
    * @param psOprationName 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private XmlObject getOperation(XmlObject pXmlWsdl, String psBindingName, String psOprationName)
   {
      XmlObject port =
         pXmlWsdl.createObject("service").findSubObject("port", "name", psBindingName);

      if (port == null) {
         XmlObject[] binding = pXmlWsdl.getObjects("binding");
         boolean ok = false;

         for (int i = 0; i < binding.length; i++) {
            String sType = binding[i].getAttribute("type");

            if (sType.equals(psBindingName) || sType.endsWith(":" + psBindingName)) {
               psBindingName = binding[i].getAttribute("name");
               ok = true;
            }
         }

         if (!ok) {
            return null;
         }
      } else {
         psBindingName = port.getAttribute("binding");
      }

      if (psBindingName.indexOf(":") > 0) {
         psBindingName = psBindingName.substring(psBindingName.indexOf(":") + 1);
      }

      XmlObject binding = pXmlWsdl.findSubObject("binding", "name", psBindingName);

      if (binding != null) {
         XmlObject operation = binding.findSubObject("operation", "name", psOprationName);

         return operation;
      }

      return null;
   }

   /** 
    * Method url2ImportPath 
    * 
    * @param psUrlPath 
    * @return 
    * 
    * @author Andreas Brod 
    */
   private String url2ImportPath(String psUrlPath)
   {
      String sAccept = "\\./";

      if (psUrlPath.indexOf(":") > 0) {
         psUrlPath = psUrlPath.substring(psUrlPath.indexOf(":") + 1);
      }

      while ((psUrlPath.length() > 0) && (sAccept.indexOf(psUrlPath.charAt(0)) >= 0)) {
         psUrlPath = psUrlPath.substring(1);
      }

      String s = "";

      // eliminate special chars
      for (int i = 0; i < psUrlPath.length(); i++) {
         char c = psUrlPath.charAt(i);

         if ((c >= 'A') && (c <= 'Z')) {
            c += 32;
         }

         if (c == ':') {
            c = '.';
         }

         if (((c >= 'a') && (c <= 'z')) || ((c >= '0') && (c <= '9'))
               || (sAccept.indexOf("" + c) >= 0)) {
            if ((c >= '0') && (c <= '9')
                  && ((s.length() == 0) || (sAccept.indexOf(s.substring(s.length() - 1)) >= 0))) {
               s += "p";
            }

            s += c;
         }
      }

      if (s.indexOf("//") > 0) {
         s = s.substring(s.lastIndexOf("//") + 2);
      }

      if (s.indexOf("\\\\") > 0) {
         s = s.substring(s.lastIndexOf("\\\\") + 2);
      }

      if (s.indexOf("/") > 0) {

         // sort other order
         StringTokenizer st = new StringTokenizer(s.substring(0, s.indexOf("/")), ".:");

         s = s.substring(s.indexOf("/"));

         while (st.hasMoreTokens()) {
            if (!s.startsWith("/")) {
               s = "." + s;
            }

            s = st.nextToken() + s;
         }
      }

      while (s.indexOf("/") > 0) {
         s = s.substring(0, s.indexOf("/")) + "." + s.substring(s.indexOf("/") + 1);
      }

      while (s.indexOf("\\") > 0) {
         s = s.substring(0, s.indexOf("\\")) + "." + s.substring(s.indexOf("\\") + 1);
      }

      // remove trailing .
      if (s.endsWith(".")) {
         s = s.substring(0, s.length() - 1);
      }

      return s;
   }


   /** 
    * static method correctCommunication 
    * 
    * @param psImportDirectory ImportDirectory
    * @param psJavaCommunicationFileName JavaCommunicationFileName
    * 
    * @author brod 
    */
   public static void correctCommunication(String psImportDirectory,
                                           String psJavaCommunicationFileName)
   {
      XmlObject schema;
      try {
         schema = new XmlObject(new File(psImportDirectory + "/data.xsd")).getFirstObject();
      }
      catch (FileNotFoundException e1) {
         return;
      }
      // get the elements
      XmlObject[] objects = schema.getObjects("element");
      HashSet<String> hsFiles = new HashSet<String>();
      for (int i = 0; i < objects.length; i++) {
         hsFiles.add(Util.camelCase(objects[i].getAttribute("name")));
      }
      // read the java file
      try {
         BufferedReader reader = new BufferedReader(new FileReader(psJavaCommunicationFileName));
         StringBuffer sb = new StringBuffer();
         String sLine;
         String sName = "";
         String sPackage = "";
         while ((sLine = reader.readLine()) != null) {
            if (sLine.trim().startsWith("// ---- START[")) {
               sName = sLine.substring(sLine.indexOf("[") + 1, sLine.indexOf("]")).trim();
            } else if (sLine.trim().startsWith("// ---- END")) {
               sName = "";
               sPackage = "";
            } else if (sName.length() > 0 && sLine.trim().startsWith("public ")) {
               StringTokenizer st = new StringTokenizer(sLine, " ");
               st.nextToken();
               if (st.hasMoreTokens()) {
                  String nextToken = st.nextToken();
                  if (nextToken.indexOf(".") > 0) {
                     sPackage = nextToken.substring(0, nextToken.lastIndexOf(".") + 1);
                  }
               }
            }

            if (sName.length() > 0 && sPackage.length() > 0) {
               int iStart = sLine.indexOf(sPackage);
               while (iStart >= 0) {
                  int iEnd = iStart + sPackage.length();
                  // get item at position
                  StringTokenizer st = new StringTokenizer(sLine.substring(iEnd), " ().");
                  String sItem = st.nextToken();
                  String sFill = "";
                  if (!hsFiles.contains(sItem)) {
                     sFill = sName + ".";
                     iStart = iEnd;
                  }
                  sLine = sLine.substring(0, iStart) + sFill + sLine.substring(iEnd);

                  iStart = sLine.indexOf(sPackage, iStart);
               }
            }

            sb.append(sLine + "\n");
         }
         Util.writeToFile(psJavaCommunicationFileName, sb.toString());
      }
      catch (Exception e) {}
   }

   /** 
    * static method getUrlsFromCommunication 
    * 
    * @param psJavaCommunicationFileName JavaCommunicationFileName
    * @return array of files
    * 
    * @author brod 
    */
   public static String[] getUrlsFromCommunication(String psJavaCommunicationFileName)
   {
      List<String> lst = new ArrayList<String>();
      try {
         BufferedReader reader = new BufferedReader(new FileReader(psJavaCommunicationFileName));
         String sLine;
         boolean bComment = false;
         while ((sLine = reader.readLine()) != null) {
            sLine = sLine.trim();
            if (sLine.startsWith("//")) {
               if (sLine.startsWith("// ---- START")) {
                  bComment = true;
               } else if (bComment) {
                  if (sLine.startsWith("// URL: ")) {
                     lst.add(sLine.substring(8).trim());
                  }
               }
            } else if (bComment) {
               // line is no comment any more
               bComment = false;
            }

         }
      }
      catch (Exception ex) {}

      return lst.toArray(new String[0]);
   }
}


/** 
 * class Data 
 * 
 * <p> 
 * Copyright &copy; 2011, i:FAO 
 * 
 * @author brod 
 */
class Data
{

   /** 
    * method loadURL 
    * 
    * @param psUrl Url to load
    * @return content of the url
    * 
    * @author brod 
    */
   public static String loadURL(String psUrl)
   {
      return UtilSwt.loadFromURL(psUrl);
   }

   /** 
    * method loadFile 
    * 
    * @param pFileToLoad FileToLoad
    * @return content of the file
    * 
    * @author brod 
    */
   public static String loadFile(File pFileToLoad)
   {
      return Util.loadFromFile(pFileToLoad.getAbsolutePath());
   }

   /** 
    * method writeFile 
    * 
    * @param psFileName filename
    * @param psTextToWrite text to write
    * 
    * @author brod 
    */
   public static void writeFile(String psFileName, String psTextToWrite)
   {
      Util.writeToFile(psFileName, psTextToWrite);
   }

}
